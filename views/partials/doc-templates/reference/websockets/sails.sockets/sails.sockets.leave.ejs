<h1 id="-leave-">.leave()</h1>
<p>Unsubscribe a socket from a room.</p>
<pre><code data-language="javascript">sails.sockets.leave(socket, roomName);
</code></pre><!-- __LANG=%%__ -->
<p><em>Or:</em></p>
<ul>
<li><code>sails.sockets.leave(socket, roomName, cb);</code></li>
</ul>
<h3 id="usage" permalink="usage">Usage</h3>
<table>
<thead>
<tr>
<th></th>
<th>Argument</th>
<th style="text-align:center">Type</th>
<th style="text-align:left">Details</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>socket</code></td>
<td style="text-align:center"><bubble type="string" colors="true"></bubble>, <bubble type="req" colors="true"></bubble></td>
<td style="text-align:left">The socket to be unsubscribed.  May be specified by the socket&apos;s id or a socket request (<code>req</code>).</td>
</tr>
<tr>
<td>2</td>
<td><code>roomName</code></td>
<td style="text-align:center"><bubble type="string" colors="true"></bubble></td>
<td style="text-align:left">The name of the room to which the socket will be subscribed.  If the room does not exist yet, it will be created.</td>
</tr>
<tr>
<td>3</td>
<td><em><code>cb</code></em></td>
<td style="text-align:center"><bubble type="function?" colors="true"></bubble></td>
<td style="text-align:left">An optional callback which will be called when the operation is complete on the current server (see notes below for more information), or if fatal errors were encountered.  In the case of errors, it will be called with a single argument (<code>err</code>).</td>
</tr>
</tbody>
</table>
<h3 id="example" permalink="example">Example</h3>
<p>In a controller action:</p>
<pre><code data-language="javascript">leaveFunRoom: function(req, res) {
  if ( _.isUndefined(req.param(&apos;roomName&apos;)) ) {
    return res.badRequest(&apos;`roomName` is required.&apos;);
  }

  if (!req.isSocket) {
    return res.badRequest(&apos;This endpoints only supports socket requests.&apos;);
  }

  var roomName = req.param(&apos;roomName&apos;);
  sails.sockets.leave(req, roomName, function(err) {
    if (err) {return res.serverError(err);}
    return res.json({
      message: &apos;Left a fun room called &apos;+roomName+&apos;!&apos;
    });
  });
}
</code></pre><!-- __LANG=%%__ -->
<pre><code data-language="javascript">kickSocketFromRoom: function(req, res) {
  if ( _.isUndefined(req.param(&apos;socketId&apos;)) || _.isUndefined(req.param(&apos;roomName&apos;)) ) {
    return res.badRequest(&apos;`socketId` and `roomName` are required.&apos;);
  }

  // Since this is using a socket id explicitly, instead of inferring one from `req`,
  // we don&apos;t have to check `isSocket`.  Note that `req` is not passed in-- instead we use a string socket id.
  sails.sockets.leave(req.param(&apos;socketId&apos;), req.param(&apos;roomName&apos;), function(err) {
    if (err) {return res.serverError(err);}
    return res.json({
      message: &apos;Socket:`&apos;+req.param(&apos;socketId&apos;)+&apos;` was kicked from room: `&apos;+req.param(&apos;roomName&apos;)+&apos;`.  No more fun, ever!&apos;
    });
  });
}
</code></pre><!-- __LANG=%%__ -->
<h3 id="notes" permalink="notes">Notes</h3>
<blockquote>
<ul>
<li>In a multi-server environment, when calling <code>.leave()</code> with a socket ID argument, the callback function (<code>cb</code>) will be executed when the <code>.leave()</code> call completes <em>on the current server</em>.  This does not guarantee that other servers in the cluster have already finished running the operation.</li>
<li>Be sure and check <code>req.isSocket === true</code> before passing in <code>req</code> to refer to the requesting socket.  The provided <code>req</code> must be from a socket request, not just any old HTTP request.</li>
</ul>
</blockquote>
<p><docmeta name="displayName" value=".leave()"></docmeta></p>
<docmeta name="pageType" value="method">
</docmeta>